// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import { ethereum, JSONValue, TypedMap, Entity, Bytes, Address, BigInt } from '@graphprotocol/graph-ts'

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this)
  }
}

export class Approval__Params {
  _event: Approval

  constructor(event: Approval) {
    this._event = event
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get approved(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class ApprovalForAll extends ethereum.Event {
  get params(): ApprovalForAll__Params {
    return new ApprovalForAll__Params(this)
  }
}

export class ApprovalForAll__Params {
  _event: ApprovalForAll

  constructor(event: ApprovalForAll) {
    this._event = event
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get operator(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get approved(): boolean {
    return this._event.parameters[2].value.toBoolean()
  }
}

export class ConsecutiveTransfer extends ethereum.Event {
  get params(): ConsecutiveTransfer__Params {
    return new ConsecutiveTransfer__Params(this)
  }
}

export class ConsecutiveTransfer__Params {
  _event: ConsecutiveTransfer

  constructor(event: ConsecutiveTransfer) {
    this._event = event
  }

  get fromTokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt()
  }

  get toTokenId(): BigInt {
    return this._event.parameters[1].value.toBigInt()
  }

  get from(): Address {
    return this._event.parameters[2].value.toAddress()
  }

  get to(): Address {
    return this._event.parameters[3].value.toAddress()
  }
}

export class Locked extends ethereum.Event {
  get params(): Locked__Params {
    return new Locked__Params(this)
  }
}

export class Locked__Params {
  _event: Locked

  constructor(event: Locked) {
    this._event = event
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt()
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this)
  }
}

export class Transfer__Params {
  _event: Transfer

  constructor(event: Transfer) {
    this._event = event
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class Unlocked extends ethereum.Event {
  get params(): Unlocked__Params {
    return new Unlocked__Params(this)
  }
}

export class Unlocked__Params {
  _event: Unlocked

  constructor(event: Unlocked) {
    this._event = event
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt()
  }
}

export class ChronosTraveler extends ethereum.SmartContract {
  static bind(address: Address): ChronosTraveler {
    return new ChronosTraveler('ChronosTraveler', address)
  }

  balanceOf(owner: Address): BigInt {
    let result = super.call('balanceOf', 'balanceOf(address):(uint256)', [ethereum.Value.fromAddress(owner)])

    return result[0].toBigInt()
  }

  try_balanceOf(owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('balanceOf', 'balanceOf(address):(uint256)', [ethereum.Value.fromAddress(owner)])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  getApproved(tokenId: BigInt): Address {
    let result = super.call('getApproved', 'getApproved(uint256):(address)', [
      ethereum.Value.fromUnsignedBigInt(tokenId),
    ])

    return result[0].toAddress()
  }

  try_getApproved(tokenId: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall('getApproved', 'getApproved(uint256):(address)', [
      ethereum.Value.fromUnsignedBigInt(tokenId),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  isApprovedForAll(owner: Address, operator: Address): boolean {
    let result = super.call('isApprovedForAll', 'isApprovedForAll(address,address):(bool)', [
      ethereum.Value.fromAddress(owner),
      ethereum.Value.fromAddress(operator),
    ])

    return result[0].toBoolean()
  }

  try_isApprovedForAll(owner: Address, operator: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall('isApprovedForAll', 'isApprovedForAll(address,address):(bool)', [
      ethereum.Value.fromAddress(owner),
      ethereum.Value.fromAddress(operator),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  locked(ticketTokenIds: Array<BigInt>): Array<boolean> {
    let result = super.call('locked', 'locked(uint256[]):(bool[])', [
      ethereum.Value.fromUnsignedBigIntArray(ticketTokenIds),
    ])

    return result[0].toBooleanArray()
  }

  try_locked(ticketTokenIds: Array<BigInt>): ethereum.CallResult<Array<boolean>> {
    let result = super.tryCall('locked', 'locked(uint256[]):(bool[])', [
      ethereum.Value.fromUnsignedBigIntArray(ticketTokenIds),
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBooleanArray())
  }

  locked1(tokenId: BigInt): boolean {
    let result = super.call('locked', 'locked(uint256):(bool)', [ethereum.Value.fromUnsignedBigInt(tokenId)])

    return result[0].toBoolean()
  }

  try_locked1(tokenId: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('locked', 'locked(uint256):(bool)', [ethereum.Value.fromUnsignedBigInt(tokenId)])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  maxSupply(): BigInt {
    let result = super.call('maxSupply', 'maxSupply():(uint256)', [])

    return result[0].toBigInt()
  }

  try_maxSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('maxSupply', 'maxSupply():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  ownerOf(tokenId: BigInt): Address {
    let result = super.call('ownerOf', 'ownerOf(uint256):(address)', [ethereum.Value.fromUnsignedBigInt(tokenId)])

    return result[0].toAddress()
  }

  try_ownerOf(tokenId: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall('ownerOf', 'ownerOf(uint256):(address)', [ethereum.Value.fromUnsignedBigInt(tokenId)])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  totalSupply(): BigInt {
    let result = super.call('totalSupply', 'totalSupply():(uint256)', [])

    return result[0].toBigInt()
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('totalSupply', 'totalSupply():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this)
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this)
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall

  constructor(call: ApproveCall) {
    this._call = call
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get tokenId(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall

  constructor(call: ApproveCall) {
    this._call = call
  }
}

export class BurnCall extends ethereum.Call {
  get inputs(): BurnCall__Inputs {
    return new BurnCall__Inputs(this)
  }

  get outputs(): BurnCall__Outputs {
    return new BurnCall__Outputs(this)
  }
}

export class BurnCall__Inputs {
  _call: BurnCall

  constructor(call: BurnCall) {
    this._call = call
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt()
  }
}

export class BurnCall__Outputs {
  _call: BurnCall

  constructor(call: BurnCall) {
    this._call = call
  }
}

export class BurnBatchCall extends ethereum.Call {
  get inputs(): BurnBatchCall__Inputs {
    return new BurnBatchCall__Inputs(this)
  }

  get outputs(): BurnBatchCall__Outputs {
    return new BurnBatchCall__Outputs(this)
  }
}

export class BurnBatchCall__Inputs {
  _call: BurnBatchCall

  constructor(call: BurnBatchCall) {
    this._call = call
  }

  get ids(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray()
  }
}

export class BurnBatchCall__Outputs {
  _call: BurnBatchCall

  constructor(call: BurnBatchCall) {
    this._call = call
  }
}

export class BurnBatchByFacetCall extends ethereum.Call {
  get inputs(): BurnBatchByFacetCall__Inputs {
    return new BurnBatchByFacetCall__Inputs(this)
  }

  get outputs(): BurnBatchByFacetCall__Outputs {
    return new BurnBatchByFacetCall__Outputs(this)
  }
}

export class BurnBatchByFacetCall__Inputs {
  _call: BurnBatchByFacetCall

  constructor(call: BurnBatchByFacetCall) {
    this._call = call
  }

  get ids(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray()
  }
}

export class BurnBatchByFacetCall__Outputs {
  _call: BurnBatchByFacetCall

  constructor(call: BurnBatchByFacetCall) {
    this._call = call
  }
}

export class BurnByFacetCall extends ethereum.Call {
  get inputs(): BurnByFacetCall__Inputs {
    return new BurnByFacetCall__Inputs(this)
  }

  get outputs(): BurnByFacetCall__Outputs {
    return new BurnByFacetCall__Outputs(this)
  }
}

export class BurnByFacetCall__Inputs {
  _call: BurnByFacetCall

  constructor(call: BurnByFacetCall) {
    this._call = call
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt()
  }
}

export class BurnByFacetCall__Outputs {
  _call: BurnByFacetCall

  constructor(call: BurnByFacetCall) {
    this._call = call
  }
}

export class LockByFacetCall extends ethereum.Call {
  get inputs(): LockByFacetCall__Inputs {
    return new LockByFacetCall__Inputs(this)
  }

  get outputs(): LockByFacetCall__Outputs {
    return new LockByFacetCall__Outputs(this)
  }
}

export class LockByFacetCall__Inputs {
  _call: LockByFacetCall

  constructor(call: LockByFacetCall) {
    this._call = call
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt()
  }
}

export class LockByFacetCall__Outputs {
  _call: LockByFacetCall

  constructor(call: LockByFacetCall) {
    this._call = call
  }
}

export class LockByFacet1Call extends ethereum.Call {
  get inputs(): LockByFacet1Call__Inputs {
    return new LockByFacet1Call__Inputs(this)
  }

  get outputs(): LockByFacet1Call__Outputs {
    return new LockByFacet1Call__Outputs(this)
  }
}

export class LockByFacet1Call__Inputs {
  _call: LockByFacet1Call

  constructor(call: LockByFacet1Call) {
    this._call = call
  }

  get ids(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray()
  }
}

export class LockByFacet1Call__Outputs {
  _call: LockByFacet1Call

  constructor(call: LockByFacet1Call) {
    this._call = call
  }
}

export class MintByFacetCall extends ethereum.Call {
  get inputs(): MintByFacetCall__Inputs {
    return new MintByFacetCall__Inputs(this)
  }

  get outputs(): MintByFacetCall__Outputs {
    return new MintByFacetCall__Outputs(this)
  }
}

export class MintByFacetCall__Inputs {
  _call: MintByFacetCall

  constructor(call: MintByFacetCall) {
    this._call = call
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class MintByFacetCall__Outputs {
  _call: MintByFacetCall

  constructor(call: MintByFacetCall) {
    this._call = call
  }
}

export class MintByFacet1Call extends ethereum.Call {
  get inputs(): MintByFacet1Call__Inputs {
    return new MintByFacet1Call__Inputs(this)
  }

  get outputs(): MintByFacet1Call__Outputs {
    return new MintByFacet1Call__Outputs(this)
  }
}

export class MintByFacet1Call__Inputs {
  _call: MintByFacet1Call

  constructor(call: MintByFacet1Call) {
    this._call = call
  }

  get tos(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray()
  }

  get amounts(): Array<BigInt> {
    return this._call.inputValues[1].value.toBigIntArray()
  }
}

export class MintByFacet1Call__Outputs {
  _call: MintByFacet1Call

  constructor(call: MintByFacet1Call) {
    this._call = call
  }
}

export class SafeTransferFromCall extends ethereum.Call {
  get inputs(): SafeTransferFromCall__Inputs {
    return new SafeTransferFromCall__Inputs(this)
  }

  get outputs(): SafeTransferFromCall__Outputs {
    return new SafeTransferFromCall__Outputs(this)
  }
}

export class SafeTransferFromCall__Inputs {
  _call: SafeTransferFromCall

  constructor(call: SafeTransferFromCall) {
    this._call = call
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get tokenId(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }
}

export class SafeTransferFromCall__Outputs {
  _call: SafeTransferFromCall

  constructor(call: SafeTransferFromCall) {
    this._call = call
  }
}

export class SafeTransferFrom1Call extends ethereum.Call {
  get inputs(): SafeTransferFrom1Call__Inputs {
    return new SafeTransferFrom1Call__Inputs(this)
  }

  get outputs(): SafeTransferFrom1Call__Outputs {
    return new SafeTransferFrom1Call__Outputs(this)
  }
}

export class SafeTransferFrom1Call__Inputs {
  _call: SafeTransferFrom1Call

  constructor(call: SafeTransferFrom1Call) {
    this._call = call
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get tokenId(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes()
  }
}

export class SafeTransferFrom1Call__Outputs {
  _call: SafeTransferFrom1Call

  constructor(call: SafeTransferFrom1Call) {
    this._call = call
  }
}

export class SetApprovalForAllCall extends ethereum.Call {
  get inputs(): SetApprovalForAllCall__Inputs {
    return new SetApprovalForAllCall__Inputs(this)
  }

  get outputs(): SetApprovalForAllCall__Outputs {
    return new SetApprovalForAllCall__Outputs(this)
  }
}

export class SetApprovalForAllCall__Inputs {
  _call: SetApprovalForAllCall

  constructor(call: SetApprovalForAllCall) {
    this._call = call
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get approved(): boolean {
    return this._call.inputValues[1].value.toBoolean()
  }
}

export class SetApprovalForAllCall__Outputs {
  _call: SetApprovalForAllCall

  constructor(call: SetApprovalForAllCall) {
    this._call = call
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this)
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this)
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall

  constructor(call: TransferFromCall) {
    this._call = call
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get tokenId(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall

  constructor(call: TransferFromCall) {
    this._call = call
  }
}

export class UnlockByFacetCall extends ethereum.Call {
  get inputs(): UnlockByFacetCall__Inputs {
    return new UnlockByFacetCall__Inputs(this)
  }

  get outputs(): UnlockByFacetCall__Outputs {
    return new UnlockByFacetCall__Outputs(this)
  }
}

export class UnlockByFacetCall__Inputs {
  _call: UnlockByFacetCall

  constructor(call: UnlockByFacetCall) {
    this._call = call
  }

  get ids(): Array<BigInt> {
    return this._call.inputValues[0].value.toBigIntArray()
  }
}

export class UnlockByFacetCall__Outputs {
  _call: UnlockByFacetCall

  constructor(call: UnlockByFacetCall) {
    this._call = call
  }
}

export class UnlockByFacet1Call extends ethereum.Call {
  get inputs(): UnlockByFacet1Call__Inputs {
    return new UnlockByFacet1Call__Inputs(this)
  }

  get outputs(): UnlockByFacet1Call__Outputs {
    return new UnlockByFacet1Call__Outputs(this)
  }
}

export class UnlockByFacet1Call__Inputs {
  _call: UnlockByFacet1Call

  constructor(call: UnlockByFacet1Call) {
    this._call = call
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt()
  }
}

export class UnlockByFacet1Call__Outputs {
  _call: UnlockByFacet1Call

  constructor(call: UnlockByFacet1Call) {
    this._call = call
  }
}
